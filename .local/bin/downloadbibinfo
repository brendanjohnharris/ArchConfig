#!/bin/bash
#
# Download bibliography information using OneCite CLI and import to JabRef
# Supports DOI, arXiv IDs, paper titles, and URLs
#
# Requirements: onecite CLI (install via: pip install onecite)
#

set -euo pipefail  # Exit on error, undefined variables, and pipe failures

# Configuration
readonly DIR="$HOME/Notebook/Papers/"

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly NC='\033[0m' # No Color

# Function to show error messages
error() {
    echo -e "${RED}Error: $1${NC}" >&2
    notify-send "Error" "$1" -u critical 2>/dev/null || true
    exit 1
}

# Function to show info messages
info() {
    echo -e "${GREEN}$1${NC}"
    notify-send "$1" 2>/dev/null || true
}

# Function to show warning messages
warn() {
    echo -e "${YELLOW}Warning: $1${NC}"
    notify-send "Warning" "$1" -u normal 2>/dev/null || true
}

# Check for unique filename with suffix support (a, b, c, etc.)
check_file_name() {
    local base_name="$1"
    local counter=0
    local suffix=""
    local chars=(a b c d e f g h i j k l m n o p q r s t u v w x y z)

    while true; do
        local new_name="${base_name}${suffix}.pdf"

        # Check if file doesn't exist
        if [[ ! -f "${DIR}${new_name}" ]] && [[ $(find "$DIR" -type f -name "${base_name}${suffix}.pdf" 2>/dev/null | wc -l) -eq 0 ]]; then
            echo "$new_name"
            return 0
        fi

        # Update suffix for next iteration
        if [[ $counter -ge ${#chars[@]} ]]; then
            error "Too many files with base name '$base_name'"
        fi
        suffix="${chars[$counter]}"
        counter=$((counter + 1))
    done
}

# Extract field from BibTeX entry
extract_bibtex_field() {
    local bib="$1"
    local field="$2"

    # Extract value using sed (handles both braces and quotes)
    local value
    value=$(echo "$bib" | sed -n "s/.*${field}[[:space:]]*=[[:space:]]*[{\"]\\([^}\"]\\+\\)[}\"].*/\\1/p" | head -1)

    echo "$value"
}

# Determine the type of input (DOI, arXiv, or title)
detect_input_type() {
    local input="$1"

    if [[ "$input" =~ ^10\. ]]; then
        echo "DOI"
    elif [[ "$input" =~ ^(arXiv:)?[0-9]{4}\.[0-9]{4,5}(v[0-9]+)?$ ]]; then
        echo "arXiv"
    elif [[ "$input" =~ ^https?:// ]]; then
        echo "URL"
    else
        echo "title"
    fi
}

# Fetch citation using OneCite CLI in interactive mode
fetch_citation() {
    local source="$1"

    # Create temp files for input and output
    local tmp_input tmp_output
    tmp_input=$(mktemp /tmp/onecite_input_XXXXXX.txt)
    tmp_output=$(mktemp /tmp/onecite_output_XXXXXX.bib)
    echo "$source" > "$tmp_input"

    # Detect available terminal emulator with custom WM_CLASS for xmonad floating
    local terminal_cmd=""
    local wm_class="downloadbibinfo"

    if command -v alacritty &> /dev/null; then
        terminal_cmd="alacritty --class '$wm_class' --title '$wm_class' -e"
    elif command -v gnome-terminal &> /dev/null; then
        terminal_cmd="gnome-terminal --title='$wm_class' --wait --"
    elif command -v konsole &> /dev/null; then
        terminal_cmd="konsole --name '$wm_class' -e"
    elif command -v xfce4-terminal &> /dev/null; then
        terminal_cmd="xfce4-terminal --title='$wm_class' -e"
    elif command -v xterm &> /dev/null; then
        terminal_cmd="xterm -name '$wm_class' -title '$wm_class' -e"
    elif command -v kitty &> /dev/null; then
        terminal_cmd="kitty --class '$wm_class' --title '$wm_class' -e"
    else
        warn "No terminal emulator found, running in current shell"
        terminal_cmd=""
    fi

    # Run onecite in interactive mode
    local result
    if [[ -n "$terminal_cmd" ]]; then
        # Run in popup terminal
        $terminal_cmd bash -c "onecite process '$tmp_input' --quiet --output-format bibtex --interactive --output '$tmp_output'; echo ''; echo 'Citation saved. Press Enter to close...'; read"

        # Check if output file was created
        if [[ -f "$tmp_output" && -s "$tmp_output" ]]; then
            result=$(cat "$tmp_output")
            rm -f "$tmp_input" "$tmp_output"
            echo "$result"
            return 0
        else
            rm -f "$tmp_input" "$tmp_output"
            return 1
        fi
    else
        # Fallback: run in current shell
        if result=$(onecite process "$tmp_input" --output-format bibtex --interactive --output "$tmp_output" 2>&1); then
            if [[ -f "$tmp_output" && -s "$tmp_output" ]]; then
                result=$(cat "$tmp_output")
                rm -f "$tmp_input" "$tmp_output"
                echo "$result"
                return 0
            fi
        fi
        rm -f "$tmp_input" "$tmp_output"
        return 1
    fi
}

# Main script starts here
main() {
    # Check for onecite CLI
    if ! command -v onecite &> /dev/null; then
        error "onecite CLI is required but not found. Install with: pip install onecite"
    fi

    # Get input from argument or clipboard
    local input
    if [[ $# -eq 0 ]]; then
        if command -v xclip &> /dev/null; then
            input=$(xclip -selection c -o 2>/dev/null || echo "")
        else
            error "No input provided and xclip not found for clipboard access"
        fi

        if [[ -z "$input" ]]; then
            error "No input provided and clipboard is empty"
        fi
        info "Using input from clipboard: $input"
    else
        input="$1"
    fi

    # Trim whitespace
    input=$(echo "$input" | xargs)

    # Detect input type
    local input_type
    input_type=$(detect_input_type "$input")

    # For DOI, extract just the DOI part if it's in a URL
    if [[ "$input_type" == "DOI" ]]; then
        input=$(echo "$input" | grep -oP '(10\.).*')
    fi

    info "Retrieving bibliography for $input_type: $input"

    # Fetch BibTeX using OneCite
    local bib
    if ! bib=$(fetch_citation "$input" 2>&1); then
        if [[ "$bib" == *"OneCite not installed"* ]]; then
            error "OneCite not installed. Install with: pip install onecite"
        else
            error "Failed to retrieve bibliography: $bib"
        fi
    fi

    if [[ -z "$bib" ]] || [[ "$bib" == ERROR:* ]]; then
        error "Failed to retrieve bibliography information"
    fi

    # Extract metadata from BibTeX
    local author year title key
    author=$(extract_bibtex_field "$bib" "author")
    year=$(extract_bibtex_field "$bib" "year")
    title=$(extract_bibtex_field "$bib" "title")

    # Create citation key
    if [[ -n "$author" && -n "$year" ]]; then
        # Extract first author's last name (format is "LastName, FirstName and ...")
        key=$(echo "$author" | awk -F' and ' '{print $1}' | awk -F', ' '{print $1}')
        key="${key}${year}"
    elif [[ -n "$title" && -n "$year" ]]; then
        # Fallback: use first word of title if no author
        key="$(echo "$title" | awk '{print $1}')${year}"
    else
        warn "Could not extract author/year, using timestamp"
        key="paper_$(date +%Y%m%d_%H%M%S)"
    fi

    # Sanitize filename (remove invalid characters and spaces)
    key=$(echo "$key" | sed 's/[<>:"\/\\|?*]//g' | sed 's/[[:space:]]/_/g')

    # Get unique filename
    local filename
    filename=$(check_file_name "$key")

    info "Retrieved: $title"
    info "Citation key: $key"

    # Import to JabRef
    local tmp_bib
    tmp_bib=$(mktemp /tmp/bibXXXXXXXX.bib)
    echo "$bib" > "$tmp_bib"

    if command -v jabref &> /dev/null; then
        info "Importing to JabRef..."
        if jabref -n -asfl --importToOpen "$tmp_bib" -w "$key" 2>/dev/null; then
            info "Successfully imported to JabRef"
            # Cleanup on success
            rm -f "$tmp_bib"
        else
            warn "JabRef import may have failed. BibTeX saved to: $tmp_bib"
            echo -e "\n${GREEN}BibTeX entry:${NC}\n$bib"
        fi
    else
        warn "JabRef not found. BibTeX saved to: $tmp_bib"
        echo -e "\n${GREEN}BibTeX entry:${NC}\n$bib"
        # Also save to clipboard if possible
        if command -v xclip &> /dev/null; then
            echo "$bib" | xclip -selection c
            info "BibTeX copied to clipboard"
        fi
    fi
}

# Run main function
main "$@"
